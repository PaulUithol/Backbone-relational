<!DOCTYPE HTML>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="chrome=1" />
  <meta name="viewport" content="width=device-width">
  <link rel="icon" href="docs/static/images/favicon.ico" />
  <link rel="stylesheet" type="text/css" href="docs/static/css/prism.css" />
  <title>Backbone-relational.js</title>
  <style>
    body {
      font-size: 14px;
      line-height: 1.5em;
      font-family: Helvetica Neue, Helvetica, Arial;
      background: #f4f4f4 url('docs/static/images/background.png');
    }
    .interface {
      font-family: "Lucida Grande", "Lucida Sans Unicode", Helvetica, Arial, sans-serif !important;
    }
    div#sidebar {
      background: #fff;
      position: fixed;
      z-index: 10;
      top: 0; left: 0; bottom: 0;
      width: 200px;
      overflow-y: auto;
      overflow-x: hidden;
      -webkit-overflow-scrolling: touch;
      padding: 15px 15px 30px 30px;
      border-right: 1px solid #bbb;
      box-shadow: 0 0 20px #ccc; -webkit-box-shadow: 0 0 20px #ccc; -moz-box-shadow: 0 0 20px #ccc;
    }
      a.toc_title, a.toc_title:visited {
        display: block;
        color: black;
        font-weight: bold;
        margin-top: 15px;
      }
        a.toc_title:hover {
          text-decoration: underline;
        }
        #sidebar .version {
          font-size: 10px;
          font-weight: normal;
        }
      ul.toc_section {
        font-size: 11px;
        line-height: 14px;
        margin: 5px 0 0 0;
        padding-left: 0px;
        list-style-type: none;
        font-family: Lucida Grande;
      }
        .toc_section li {
          cursor: pointer;
          margin: 0 0 3px 0;
        }
          .toc_section li a {
            text-decoration: none;
            color: black;
          }
            .toc_section li a:hover {
              text-decoration: underline;
            }
    div.container {
      position: relative;
      width: 45em;
      margin: 40px 0 50px 260px;
    }
    img#logo {
      width: 450px;
      height: 80px;
    }
    div.run {
      position: absolute;
      right: 15px;
      width: 26px; height: 18px;
      background: url('docs/images/arrows.png') no-repeat -26px 0;
    }
      div.run:active {
        background-position: -51px 0;
      }
    p, div.container ul {
      margin: 25px 0;
      width: 45em;
    }
      p.warning {
        font-size: 12px;
        line-height: 18px;
        font-style: italic;
      }
      div.container ul {
        list-style: circle;
        padding-left: 15px;
        font-size: 13px;
        line-height: 18px;
      }
        div.container ul li {
          margin-bottom: 10px;
        }
        div.container ul.small {
          font-size: 12px;
        }
    a, a:visited {
      color: #444;
    }
    a:active, a:hover {
      color: #000;
    }
    a.punch {
      display: inline-block;
      background: #4162a8;
      border-top: 1px solid #38538c;
      border-right: 1px solid #1f2d4d;
      border-bottom: 1px solid #151e33;
      border-left: 1px solid #1f2d4d;
      -webkit-border-radius: 4px;
      -moz-border-radius: 4px;
      -ms-border-radius: 4px;
      -o-border-radius: 4px;
      border-radius: 4px;
      -webkit-box-shadow: inset 0 1px 10px 1px #5c8bee, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
      -moz-box-shadow: inset 0 1px 10px 1px #5c8bee, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
      -ms-box-shadow: inset 0 1px 10px 1px #5c8bee, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
      -o-box-shadow: inset 0 1px 10px 1px #5c8bee, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
      box-shadow: inset 0 1px 10px 1px #5c8bee, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
      color: #fff;
      font: bold 14px "helvetica neue", helvetica, arial, sans-serif;
      line-height: 1;
      margin-bottom: 15px;
      padding: 8px 0 10px 0;
      text-align: center;
      text-shadow: 0px -1px 1px #1e2d4d;
      text-decoration: none;
      width: 225px;
      -webkit-background-clip: padding-box; }
      a.punch:hover {
        -webkit-box-shadow: inset 0 0px 20px 1px #87adff, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
        -moz-box-shadow: inset 0 0px 20px 1px #87adff, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
        -ms-box-shadow: inset 0 0px 20px 1px #87adff, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
        -o-box-shadow: inset 0 0px 20px 1px #87adff, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
        box-shadow: inset 0 0px 20px 1px #87adff, 0px 1px 0 #1d2c4d, 0 6px 0px #1f3053, 0 8px 4px 1px #111111;
        cursor: pointer; }
      a.punch:active {
        -webkit-box-shadow: inset 0 1px 10px 1px #5c8bee, 0 1px 0 #1d2c4d, 0 2px 0 #1f3053, 0 4px 3px 0 #111111;
        -moz-box-shadow: inset 0 1px 10px 1px #5c8bee, 0 1px 0 #1d2c4d, 0 2px 0 #1f3053, 0 4px 3px 0 #111111;
        -ms-box-shadow: inset 0 1px 10px 1px #5c8bee, 0 1px 0 #1d2c4d, 0 2px 0 #1f3053, 0 4px 3px 0 #111111;
        -o-box-shadow: inset 0 1px 10px 1px #5c8bee, 0 1px 0 #1d2c4d, 0 2px 0 #1f3053, 0 4px 3px 0 #111111;
        box-shadow: inset 0 1px 10px 1px #5c8bee, 0 1px 0 #1d2c4d, 0 2px 0 #1f3053, 0 4px 3px 0 #111111;
        margin-top: 5px; margin-bottom: 10px }
    a img {
      border: 0;
    }
    h2, h3, h4, h5, h6 {
      padding-top: 20px;
    }
      h2 {
        font-size: 22px;
      }
    b.header {
      font-size: 18px;
      line-height: 35px;
    }
    span.alias {
      font-size: 14px;
      font-style: italic;
      margin-left: 20px;
    }
    table {
      margin: 15px 0 0; padding: 0;
    }
      tr, td {
        margin: 0; padding: 0;
      }
        td {
          padding: 0px 15px 5px 0;
        }
        table .rule {
          height: 1px;
          background: #ccc;
          margin: 5px 0;
        }
    code, pre, tt {
      font-family: Monaco, Consolas, "Lucida Console", monospace;
      font-size: 12px;
      line-height: 18px;
      font-style: normal;
    }
      tt {
        padding: 0px 3px;
        background: #fff;
        border: 1px solid #ddd;
        zoom: 1;
      }
      code {
        margin-left: 20px;
      }
      pre {
        font-size: 12px;
        padding: 2px 0 2px 15px;
        border: 4px solid #bbb; border-top: 0; border-bottom: 0;
        margin: 0px 0 25px;
      }
      pre code {
        margin: 0;
      }
      img.example_image {
        margin: 0px auto;
      }
        img.example_retina {
          margin: 20px;
          box-shadow: 0 8px 15px rgba(0,0,0,0.4);
        }
    @media only screen and (-webkit-max-device-pixel-ratio: 1) and (max-width: 600px),
           only screen and (max--moz-device-pixel-ratio: 1) and (max-width: 600px) {
      div#sidebar {
        display: none;
      }
      img#logo {
        max-width: 450px;
        width: 100%;
        height: auto;
      }
      div.container {
        width: auto;
        margin-left: 15px;
        margin-right: 15px;
      }
        p, div.container ul {
          width: auto;
        }
    }
    @media only screen and (-webkit-min-device-pixel-ratio: 1.5) and (max-width: 640px),
          only screen and (-o-min-device-pixel-ratio: 3/2) and (max-width: 640px),
          only screen and (min-device-pixel-ratio: 1.5) and (max-width: 640px) {
      img {
        max-width: 100%;
        height: auto;
      }
      div#sidebar {
        -webkit-overflow-scrolling: initial;
        position: relative;
        width: 90%;
        height: 120px;
        left: 0;
        top: -7px;
        padding: 10px 0 10px 30px;
        border: 0;
      }
      img#logo {
        width: auto;
        height: auto;
      }
      div.container {
        margin: 0;
        width: 100%;
      }
      p, div.container ul {
        max-width: 98%;
        overflow-x: scroll;
      }
      table {
        position: relative;
      }
        tr:first-child td {
          padding-bottom: 25px;
        }
        td.text {
          padding: 0;
          position: absolute;
          left: 0;
          top: 48px;
        }
        tr:last-child td.text {
          top: 122px;
        }
      pre {
        overflow: scroll;
      }
    }
  </style>
</head>
<body>

  <div id="sidebar" class="interface">

    <a class="toc_title" href="#">
      Backbone-relational.js <span class="version">(0.7.1)</span>
    </a>

    <ul class="toc_section">
      <li>&raquo; <a href="https://github.com/PaulUithol/Backbone-relational">GitHub Repository</a></li>
    </ul>

    <a class="toc_title" href="#Introduction">
      Introduction
    </a>

    <a class="toc_title" href="#Installation">
      Installation
    </a>

    <a class="toc_title" href="#Relation">
      Backbone.Relation
    </a>

    <ul class="toc_section">
      <li>– <a href="#Relation-relatedModel">relatedModel</a></li>
      <li>– <a href="#Relation-key">key</a></li>
      <li>– <a href="#Relation-type">type</a></li>
      <li>– <a href="#Relation-keySource">keySource</a></li>
      <li>– <a href="#Relation-keyDestination">keyDestination</a></li>
      <li>– <a href="#Relation-collectionType">collectionType</a></li>
      <li>– <a href="#Relation-collectionKey">collectionKey</a></li>
      <li>– <a href="#Relation-includeInJSON">includeInJSON</a></li>
      <li>– <a href="#Relation-createModels">createModels</a></li>
      <li>– <a href="#Relation-reverseRelation">reverseRelation</a></li>
    </ul>

    <a class="toc_title" href="#RelationalModel">
      Backbone.RelationalModel
    </a>

    <ul class="toc_section">
      <li>– <a href="#RelationalModel-getRelations">getRelations</a></li>
      <li>– <a href="#RelationalModel-fetchRelated">fetchRelated</a></li>
      <li>– <a href="#RelationalModel-setup">setup</a></li>
      <li>– <a href="#RelationalModel-build">build</a></li>
      <li>– <a href="#RelationalModel-findOrCreate">findOrCreate</a></li>
      <li>– <a href="#RelationalModel-subModelTypes">subModelTypes</a></li>
      <li>– <a href="#RelationalModel-subModelTypeAttribute">subModelTypeAttribute</a></li>
      <li>– <a href="#RelationalModel-events"><b>Catalog of Built-in Events</b></a></li>
    </ul>

    <a class="toc_title" href="#examples">
      Examples
    </a>

    <a class="toc_title" href="#under-the-hood">
      Under the Hood
    </a>

  </div>

  <div class="container">

    <h1 id="header">
      Backbone-relational.js
    </h1>

    <p>
      When developing any medium to large-scale web application, you often get to a point where
      an action by a user could potentially cause a number of different models to change on the
      client or the server.  You could individually call <a href="http://backbonejs.org/#Model-save">save()<a>
      or <a href="http://backbonejs.org/#Model-fetch">fetch()<a/> on each of the changed models to sync
      with the server, but that would be kind of a tediuous process and result in multiple requests.
      Instead, we can configure relationships between our models, and then upon single
      <a href="http://backbonejs.org/#Model-save">save()<a> or <a href="http://backbonejs.org/#Model-fetch">
      fetch()</a>, we could sync the model and all of its related models.
    </p>

    <h2 id="Downloads">
      Downloads &amp; Dependencies
      <span style="padding-left: 7px; font-size:11px; font-weight: normal;" class="interface">(Right-click, and use
      "Save As")</span>
    </h2>

    <table>
      <tr>
        <td><a class="punch" href="https://raw.github.com/PaulUithol/Backbone-relational/master/backbone-relational.js">Development Version</a></td>
        <td class="text"><i>56kb, Full source, lots of comments</i></td>
      </tr>
      <tr>
        <td><a class="punch" href="https://raw.github.com/PaulUithol/Backbone-relational/0.7.1/backbone-relational.js">Latest Release (0.7.1)</a></td>
      </tr>
    </table>

    <p>
      Backbone-relational's only hard dependencies is
      <a href="http://backbonejs.org/">Backbone.js</a> <small>( > 0.9.10 )</small>,
      which itself requires <a href="http://underscorejs.org">Underscore.js</a> <small>( > 1.4.3 )</small> and
      <a href="http://jquery.com">jQuery</a> <small>( > 1.4.2)</small> or
      <a href="http://zeptojs.com/">Zepto</a>.
    </p>

    <h2 id="Introduction">Introduction</h2>

    <p>
      Backbone-relational.js provides one-to-one, one-to-many and many-to-one relations
      between models for Backbone. To use relations, extend <b>Backbone.RelationalModel</b> (instead of the regular
      <b>Backbone.Model</b>) and define a <tt>relations</tt> property, containing an array of option objects.
      Each relation must define (as a minimum) the <a href="#Relation-type">type</a>, <a href="#Relation-key">key</a>,
      and <a href="#Relation-relatedModel">relatedModel</a>.  Available relation types are <b>Backbone.HasOne</b> and <b>Backbone.HasMany</b>.
    </p>

    <p>
      Backbone-relational's main features include:
    </p>

    <ul>
      <li>
        Bidirectional relations, which notify related models of changes through events.
      </li>
      <li>
        Control how relations are serialized using the <tt>includeInJSON</tt> option.
      </li>
      <li>
        Automatically convert nested objects in a model's attributes into model instances using the <tt>createModels</tt>
        option.
      </li>
      <li>
        Lazily retrieve a set of related models through the <a href="#RelationalModel.fetchRelated">fetchRelated</a>
        method.
      </li>
      <li>
        Determine the type of HasMany collections with <tt>collectionType</tt>.
      </li>
    </ul>

    <p>
      You can also bind new events to a <b>Backbone.RelationalModel</b> for an:
    </p>

    <ul>
      <li>
        <b>addition</b> to a HasMany relation with <a href="#RelationalModel-events">add:&lt;key&gt;</a>.
      </li>
      <li>
        <b>removal</b> from a HasMany relation with <a href="#RelationalModel-events">remove:&lt;key&gt;</a>.
      </li>
      <li>
        <b>reset</b> of a HasMany relation with <a href="#RelationalModel-events">reset:&lt;key&gt;</a>.
      </li>
      <li>
        <b>changes</b> to the key itself on HasMany and HasOne relations with <a href="#RelationalModel-events">update:
        &lt;key&gt;</a>.
      </li>
    </ul>

    <h2 id="Installation">Installation</h2>

    <p>
      Backbone-relational depends on <a href="http://backbonejs.org/">Backbone.js</a> (and thus on
      <a href="http://underscorejs.org">Underscore.js</a>). Include Backbone-relational right after Backbone
      and Underscore:
    </p>

    <pre class="language-markup"><!--
   --><code class="language-markup"><!--
     -->&lt;script type="text/javascript" src="./js/underscore.js"&gt;&lt;/script&gt;
<!-- -->&lt;script type="text/javascript" src="./js/backbone.js"&gt;&lt;/script&gt;
<!-- -->&lt;script type="text/javascript" src="./js/backbone-relational.js"&gt;&lt;/script&gt;</code></pre>

    <h2 id="Relation">Backbone.Relation</h2>

    <p>
      Each <b>Backbone.RelationalModel</b> can contain an array of relations. Each relation supports a number of
      options, of which <a href="#Relation-relatedModel">relatedModel</a>, <a href="#Relation-key">key</a> and
      <a href="#Relation-type">type</a> are mandatory. A relation could look like the following:
    </p>

<pre class="language-javascript"><code class="language-javascript"><!--
-->Zoo = Backbone.RelationalModel.extend({
    relations: [{
        type: Backbone.HasMany,
        key: 'animals',
        relatedModel: 'Animal',
        collectionType: 'AnimalCollection',
        reverseRelation: {
            key: 'livesIn',
            includeInJSON: 'id'
            // 'relatedModel' is automatically set to 'Zoo'; the 'relationType' to 'HasOne'.
        }
    }]
});

Animal = Backbone.RelationalModel.extend({
    urlRoot: '/animal/'
});

AnimalCollection = Backbone.Collection.extend({
    model: Animal,

    url: function( models ) {
        return '/animal/' + ( models ? 'set/' + _.pluck( models, 'id' ).join(';') + '/' : '' );
    }
});</code>
</pre>

    <p id="Relation-relatedModel">
      <b class="header">relatedModel</b><code>relation.relatedModel</code>
      <br />
      A string that can be resolved to an object on the global scope, or a reference to a <b>Backbone.RelationalModel</b>.
    </p>

    <p id="Relation-key">
      <b class="header">key</b><code>relation.key</code>
      <br />
      A string that references an attribute name on <a href="#Relational-relatedModel">relatedModel</a>.
    </p>

    <p id="Relation-type">
      <b class="header">type</b><code>relation.type</code>
      <br />
      A string that references a <b>Backbone.Relation</b> type(i.e. 'HasOne') or an actual <b>Backbone.Relation</b> type
      (i.e. <b>Backbone.HasOne</b>).
    </p>

    <p>
      You can model a one-to-one or a many-to-one relationship by declaring the type as 'HasOne' or
      <b>Backbone.HasOne</b>.  The key for a HasOne relation consists of a single <b>Backbone.RelationalModel</b>. The
      default reverseRelation.type for a HasOne relation is HasMany. This can be set to HasOne instead, to create a
      one-to-one relation.
    </p>

    <p>
      You can model a one-to-many relationship by declaring the type as 'HasMany' or <b>Backbone.HasMany</b>.
      The key for a HasMany relation consists of a Backbone.Collection, containing zero or more
      <b>Backbone.RelationalModel</b>s. The default <tt>reverseRelation.type</tt> for a HasMany relation is HasOne;
      this is the only option here, since many-to-many is not supported directly.
    </p>

    <p>
      Finally, you can model a many-to-many relationship using two <b>Backbone.HasMany</b> relations, with a link
      model in between:
    </p>

<pre class="language-javascript"><code class="language-javascript"><!--
-->Person = Backbone.RelationalModel.extend({
    relations: [
        {
            type: 'HasMany',
            key: 'jobs',
            relatedModel: 'Job',
            reverseRelation: {
                key: 'person'
            }
        }
    ]
});

// A link object between 'Person' and 'Company'
Job = Backbone.RelationalModel.extend({
    defaults: {
        'startDate': null,
        'endDate': null
    }
})

Company = Backbone.RelationalModel.extend({
    relations: [
        {
            type: 'HasMany',
            key: 'employees',
            relatedModel: 'Job',
            reverseRelation: {
                key: 'company'
            }
        }
    ]
});</code>
</pre>

    <p id="Relation-keySource">
      <b class="header">keySource</b><code>relation.keySource</code>
      <br />
      A string that references an attribute of the <a href="#Relation-relatedModel">relatedModel</a>.
    </p>

    <p>
      Used to override key when determining what data to use when (de)serializing a relation, since the data backing
      your relations may use different naming conventions. For example, a Rails backend may provide the keys suffixed
      with '_id' or '_ids'. The behavior for <a href="#Relation-keySource">keySource</a> corresponds to the following
      rules:
    </p>

    <p>
      When a relation is instantiated, the contents of the <a href="#Relation-keySource">keySource</a> are used as
      it's initial data. The application uses the regular key attribute to interface with the relation and the models
      in it; the <a href="#Relation-keySource">keySource</a> is not available as an attribute for the model. So you
      may be provided with data containing <tt>animal_ids</tt>, while you want to access this relation as zoo.get(
      'animals').
    </p>

    <p class="warning">
      Note for backward compatibility reasons, setting <a href="#Relation-keySource">keySource</a> will set
      <a href="#Relation-keyDestination">keyDestination</a> as well. This means that when saving zoo, the animals
      attribute will be serialized back into the <tt>animal_ids</tt> key.
    </p>

    <p class="warning">
      WARNING: when using a <a href="#Relation-keySource">keySource</a>, you should not use that attribute name for
      other purposes.
    </p>

    <p id="Relation-keyDestination">
      <b class="header">keyDestination</b><code>relation.keyDestination</code>
      <br />
      A string that references an attribute to serialize <a href="#Relation-relatedModel">relatedModel</a> into.
    </p>

    <p>
      Used to override key (and <a href="#Relation-keySource">keySource</a>) when determining what attribute to be
      written into when serializing a relation, since the server backing your relations may use different naming
      conventions. For example, a Rails backend may expect the keys to be suffixed with _attributes for nested
      attributes.
    </p>

    <p>
      When calling <a href="http://backbonejs.org/#Model-toJSON">toJSON</a> on a model (either via
      <b>Backbone.Sync</b>, or directly), the data in the key attribute is transformed and assigned to the
      <a href="#Relation-keyDestination">keyDestination</a>.
    </p>

    <p>
      So you may want a relation to be serialized into the animals_attributes key, while you want to access this
      relation as <tt>zoo.get( 'animals' );</tt>.
    </p>

    <p class="warning">
      WARNING: when using a <a href="#Relation-keyDestination">keyDestination</a>, you should not use that attribute name for other purposes.
    </p>

    <p id="Relation-collectionType">
      <b class="header">collectionType</b><code>relation.collectionType</code>
      <br />
      A string that can be resolved to an object type on the global scope, or a reference to a <b>Backbone.Collection
      </b> type.
    </p>

    <p>
      Determine the type of collections used for a HasMany relation. If you define a
      url(models&lt;Backbone.Model[]&gt;) function on the specified collection, this enables
      <a href="#Relation-fetchRelated">fetchRelated</a> to fetch all missing models in one request, instead of
      firing a separate request for each.
    </p>

    <p id="Relation-collectionKey">
      <b class="header">collectionKey</b><code>relation.collectionKey</code>
      <br />
      A string or a boolean.
    </p>

    <p>
      Used to create a back reference from the <b>Backbone.Collection</b> used for a HasMany relation to the model on
      the other side of this relation. By default, the relation's key attribute will be used to create a reference to
      the RelationalModel instance from the generated collection. If you set <a href="#Relation-collectionKey">
      collectionKey</a> to a string, it will use that string as the reference to the RelationalModel, rather than the
      relation's key attribute. If you don't want this behavior at all, set <a href="#Relation-collectionKey">
      collectionKey</a> to false (or any falsy value) and this reference will not be created.
    </p>

    <p id="Relation-collectionOptions">
      <b class="header">collectionOptions</b><code>relation.collectionOptions</code>
      <br />
      An options hash or a function that accepts an instance of a <b>Backbone.RelationalModel</b> and returns an option
      hash
    </p>

    <p>
      Used to provide options for the initialization of the collection in the 'Many'-end of a HasMany relation. Can be
      an options hash or a function that should take the instance in the 'One'-end of the 'HasMany' relation and return
      an options hash.
    </p>

    <p id="Relation-includeInJSON">
      <b class="header">includeInJSON</b><code>relation.includeInJSON</code>
      <br />
      A boolean, a string referencing one of the model's attributes, or an array of strings referencing model
      attributes. <a href="#Relation-includeInJson">includeInJson</a> is equal to <tt>true</tt> by default.
    </p>

    <p>
      Determines how the contents of a relation will be serialized following a call to the
      <a href="http://backbonejs.org/#Model-toJSON">toJSON</a> method. If you specify a:
    </p>

    <ul>
      <li>
        <b>Boolean</b>: a value of true serializes the full set of attributes on the related model(s). Set to false to
        exclude the relation completely.
      </li>
      <li>
        <b>String</b>: include a single attribute from the related model(s). For example, 'name', or
        <tt>Backbone.Model.prototype.idAttribute</tt> to include ids.
      </li>
      <li>
        <b>String[]</b>: includes the specified attributes from the related model(s).
      </li>
    </ul>

    <p>
      Only specifying true is cascading, meaning the relations of the model will get serialized as well!
    </p>

    <p id="Relation-createModels">
      <b class="header">createModels</b><code>relation.createModels</code>
      <br />
      A boolean. By default it is equal to <tt>true</tt>.
    </p>

    <p>
      Specifies whether models be created from nested objects or not.
    </p>

    <p id="Relation-reverseRelation">
      <b class="header">reverseRelation</b><code>relation.reverseRelation</code>
      <br />
      If the relation should be bidirectional, specify the details for the reverse relation here. It's only mandatory
      to supply a <a href="#Relation-key">key</a>; <a href="#Relation-relatedModel">relatedModel</a> is automatically
      set. The default type for a <a href="#Relation-reverseRelation">reverseRelation</a> is HasMany for a
      HasOne relation (which can be overridden to HasOne in order to create a one-to-one relation), and HasOne for a
      HasMany relation. In this case, you cannot create a <a href="#Relation-reverseRelation">reverseRelation</a> with
      type HasMany as well; please see Many-to-many relations on how to model these type of relations.
    </p>

    <p class="warning">
      Note that if you define a relation (plus a <a href="#Relation-reverseRelation">reverseRelation</a>) on a model,
      but never actually create an instance of that model, the model's constructor will never run, which means it's
      initializeRelations will never get called, and the <a href="#Relation-reverseRelation">reverseRelation</a> will
      not be initialized either. In that case, you could either define the relation on the opposite model, or define
      two single relations. See issue 20 for a discussion.
    </p>

    <p id="Relation-autoFetch">
      <b class="header">autoFetch</b><code>relation.autoFetch</code>
      <br />
      A boolean or an object. Defaults to <tt>false</tt>.
    </p>

    <p>
      If this property is set to <tt>true</tt>, when a model is instantiated the related model is
      automatically fetched using <a href="#RelationModel-fetchRelated">fetchRelated</a>. The
      value of the property can also be an object. In that case the related model is
      automatically fetched and the object is passed to <a href="#RelationalModel-fetchRelated">
      fetchRelated</a> as the options parameter.
    </p>

<pre class="language-javascript"><code class="language-javascript"><!--
-->var Shop = Backbone.RelationalModel.extend({
    relations: [{
            type: Backbone.HasMany,
            key: 'customers',
            relatedModel: 'Customer',
            autoFetch: true
        },{
            type: Backbone.HasOne,
            key: 'address',
            relatedModel: 'Address',
            autoFetch: {
                success: function(model, response){
                    //...
                },
                error: function(model, response){
                    //...
                }
            }
        }
    ]</code>
</pre>

    <h2 id="RelationalModel">
      Backbone.RelationalModel
    </h2>

    <p>
      <b>Backbone.RelationalModel</b> introduces a couple of new methods, events and properties.
      It's important to know which attributes are methods of an instance of <b>Backbone.
      RelationalModel</b>, which are methods of the type itself, and which are properties.
      These three subcategories are detailed below.
    </p>

    <p>
      <b class="header">Methods</b>
      </br>
      These methods are on an instance of a type.
    </p>

    <ul class="small">
      <li><a href="RelationalModel-getRelations">getRelations</a></li>
      <li><a href="RelationalModel-fetchRelated">fetchRelated</a></li>
    </ul>

    <p>
      <b class="header">Methods on type itself</b>
      </br>
      Several methods don't operate on model instances, but are defined on the type itself.
    </p>

    <ul class="small">
      <li><a href="RelationalModel-setup">setup</a></li>
      <li><a href="RelationalModel-build">build</a></li>
      <li><a href="RelationalModel-findOrCreate">findOrCreate</a></li>
    </ul>

    <p>
      <b class="header">Properties</b>
      </br>
      Properties can be defined along with the subclass prototype when extending Backbone.
      RelationalModel or a subclass thereof.
    </p>

    <ul class="small">
      <li><a href="RelationalModel-subModelTypes">subModelTypes</a></li>
      <li><a href="RelationalModel-subModelTypeAttribute">subModelTypeAttribute</a></li>
    </ul>

    <p id="RelationalModel-getRelations">
      <b class="header">getRelations</b><code>relationModel.getRelations()</code>
      <br />
      Returns the set of initialized relations on the model.
    </p>

    <p id="RelationalModel-fetchRelated">
      <b class="header">fetchRelated</b><code>relationalModel.fetchRelated(key&lt;string&gt;, [options&lt;object&gt;],
      [update&lt;boolean&gt;])</code>
      <br />
      Returns the set of initialized relations on the model.
    </p>

    <p>
      Fetch models from the server that were referenced in the model's attributes, but have not been found/created yet.
      This can be used specifically for lazy-loading scenarios. Setting update to true guarantees that the model will
      be fetched from the server and any model that already exists in the store will be updated with the retrieved data.
      The options object specifies options to be passed to <a href="http://backbonejs.org/#Sync">Backbone.Sync</a>.
    </p>

    <p>
      By default, a separate request will be fired for each additional model that is to be fetched from the server.
      However, if your server/API supports it, you can fetch the set of models in one request by specifying a
      collectionType for the relation you call fetchRelated on. The collectionType should have an overridden
      url(models&lt;Backbone.Model[]&gt;) method that allows it to construct a url for an array of models. See the example
      at the top of Backbone.Relation options or Backbone-tastypie for an example.
    </p>

    <p id="RelationalModel-setup">
      <b class="header">setup</b><code>relationModel.setup()</code>
      <br />
      Initialize the relations and submodels for the model type. See the Q and A for a possible scenario where it's
      useful to call this method manually.
    </p>

    <p class="warning">
      Note that this method doesn't operate on model instances, but are defined on the type itself.
    </p>

    <p id="RelationalModel-build">
      <b class="header">build</b><code>relationalModel.build(attributes&lt;object&gt;, [options&lt;object&gt;])</code>
      <br />
      Create an instance of a model, taking into account what submodels have been defined.
    </p>

    <p id="RelationalModel-findOrCreate">
      <b class="header">findOrCreate</b><code>relationalModel.findOrCreate(attributes&lt;string|number|object&gt;,
                                                                           [options&lt;object&gt;])</code>
      <br />
      Search for a model instance in the <tt>Backbone.Relational.store</tt>.
    </p>

    <ul>
      <li>
        If attributes is a string or a number, <a href="#RelationalModel-findOrCreate">findOrCreate</a> will just
        query the store and return a model if found.
      </li>
      <li>
        If attributes is an object, the model will be updated with attributes if found. Otherwise, a new model is
        created with attributes (unless options.create is explicitly set to false).
      </li>
    </ul>

    <p id="RelationalModel-subModelTypes">
      <b class="header">subModelTypes</b><code>relationalModel.subModelTypes(attributes&lt;string|number|object&gt;,
                                                                             [options&lt;object&gt;])</code>
      <br />
      An object that defaults to empty({}).
    </p>

    <p>
      A mapping that defines what submodels exist for the model (the superModel) on which
      <a href="#RelationalModel-subModelTypes">subModelTypes</a> is defined. The keys are used to match the
      <a href="#RelationalModel-subModelTypeAttribute">subModelTypeAttribute</a> when deserializing, and the values
      determine what type of submodel should be created for a key. When building model instances from data, we need to
      determine what kind of object we're dealing with in order to create instances of the right subModel type. This
      is done by finding the model for which the key is equal to the value of the
      <a href="#RelationalModel-subModelTypeAttribute">subModelTypeAttribute</a> attribute on the passed in data.
    </p>

    <p>
      Each subModel is considered to be a proper submodel of its superclass (the model type you're extending), with a
      shared id pool. This means that when looking for an object of the supermodel's type, objects of a submodel's type
      can be returned as well, as long as the id matches. In effect, any relations pointing to the supermodel will look
      for instances of it's submodels as well.
    </p>

<pre class="language-javascript"><code class="language-javascript"><!--
-->Mammal = Animal.extend({
    subModelTypes: {
        'primate': 'Primate',
        'carnivore': 'Carnivore'
    }
});
var Primate = Mammal.extend();
var Carnivore = Mammal.extend();

var MammalCollection = AnimalCollection.extend({
    model: Mammal
});

// Create a collection that contains a 'Primate' and a 'Carnivore'.
var mammals = new MammalCollection([
    { id: 3, species: 'chimp', type: 'primate' },
    { id: 5, species: 'panther', type: 'carnivore' }
]);</code>
</pre>

    <p>
      Suppose that we have an Mammal model and a Primate model extending Mammal. If we have a Primate object with id 3,
      this object will be returned when we have a relation pointing to a Mammal with id 3, as Primate is regarded a
      specific kind of Mammal; it's just a Mammal with possibly some primate-specific properties or methods.
    </p>

    <p class="warning">
      Note that this means that there cannot be any overlap in ids between instances of Mammal and Primate, as the
      Primate with id 3 will be the Mammal with id 3.
    </p>

    <p id="RelationalModel-subModelTypeAttribute">
      <b class="header">subModelTypeAttribute</b><code>relationalModel.subModelTypeAttribute</code>
      <br />
      A string that defaults to 'type'.
    </p>

    <p>
      The <a href="#Relation-subModelTypeAttribute">subModelTypeAttribute</a> is a references an attribute on the data
      used to instantiate <a href="#Relation-relatedModel">relatedModel</a>. The attribute that will be checked to
      determine the type of model that should be built when a raw object of attributes is set as the related value,
      and if the <a href="#Relation-relatedModel">relatedModel</a> has one or more submodels.
    </p>

    <p id="RelationalModel-events">
      <b class="header">Catalog of Events</b>
      <br />
      This is the complete list of all of the events that Backbone-relational makes available to you, in addition to
      those found in Backbone.
    </p>

    <ul class="small">
      <li>
        <b>"add"</b> - triggered on addition to a HasMany relation.
      </li>
      <li>
        <b>"add:&lt;key&gt;"</b> (addedModel<Backbone.Model>, related<Backbone.Collection>) - .
      </li>
      <li>
        <b>"remove"</b> - triggered on removal from a HasMany relation.
      </li>
      <li>
         <b>"remove:&lt;key&gt;"</b> (removedModel<Backbone.Model>, related<Backbone.Collection>) - .
      </li>
      <li>
        <b>"update"</b> - triggered on changes to the key itself on HasMany and HasOne relations.
      </li>
      <li>
        <b>"update:&lt;key&gt;"</b> (model<Backbone.Model>, related<Backbone.Model|Backbone.Collection>) - .
      </li>
    </ul>

    <h2 id="examples">Examples</h2>

<pre class="language-javascript"><code class="language-javascript"><!--
-->paul = new Person({
    id: 'person-1',
    name: 'Paul',
    user: { id: 'user-1', login: 'dude', email: 'me@gmail.com' }
});

// A User object is automatically created from the JSON; so 'login' returns 'dude'.
paul.get('user').get('login');

ourHouse = new House({
    id: 'house-1',
    location: 'in the middle of the street',
    occupants: ['person-1', 'person-2', 'person-5']
});

// 'ourHouse.occupants' is turned into a Backbone.Collection of Persons.
// The first person in 'ourHouse.occupants' will point to 'paul'.
ourHouse.get('occupants').at(0); // === paul

// If a collection is created from a HasMany relation, it contains a reference
// back to the originator of the relation
ourHouse.get('occupants').livesIn; // === ourHouse

// the relation from 'House.occupants' to 'Person' has been defined as a bi-directional HasMany relation,
// with a reverse relation to 'Person.livesIn'. So, 'paul.livesIn' will automatically point back to 'ourHouse'.
paul.get('livesIn'); // === ourHouse

// You can control which relations get serialized to JSON (when saving), using the 'includeInJSON'
// property on a Relation. Also, each object will only get serialized once to prevent loops.
paul.get('user').toJSON();
    /* result:
        {
            email: "me@gmail.com",
            id: "user-1",
            login: "dude",
            person: {
                id: "person-1",
                name: "Paul",
                livesIn: {
                    id: "house-1",
                    location: "in the middle of the street",
                    occupants: ["person-1"] // just the id, since 'includeInJSON' references the 'idAttribute'
                },
                user: "user-1" // not serialized because it is already in the JSON, so we won't create a loop
            }
        }
    */

// Load occupants 'person-2' and 'person-5', which don't exist yet, from the server
ourHouse.fetchRelated( 'occupants' );

// Use the 'add' and 'remove' events to listen for additions/removals on HasMany relations (like 'House.occupants').
ourHouse.bind( 'add:occupants', function( model, coll ) {
        // create a View?
        console.debug( 'add %o', model );
    });
ourHouse.bind( 'remove:occupants', function( model, coll ) {
        // destroy a View?
        console.debug( 'remove %o', model );
    });

// Use the 'update' event to listen for changes on a HasOne relation (like 'Person.livesIn').
paul.bind( 'update:livesIn', function( model, attr ) {
        console.debug( 'update to %o', attr );
    });


// Modifying either side of a bi-directional relation updates the other side automatically.
// Make paul homeless; triggers 'remove:occupants' on ourHouse, and 'update:livesIn' on paul
ourHouse.get('occupants').remove( paul.id );

paul.get('livesIn'); // yup; nothing.

// Move back in; triggers 'add:occupants' on ourHouse, and 'update:livesIn' on paul
paul.set( { 'livesIn': 'house-1' } );</code>
</pre>

  <p>This is achieved using the following relations and models:</p>

<pre class="language-javascript"><code class="language-javascript"><!--
-->House = Backbone.RelationalModel.extend({
    // The 'relations' property, on the House's prototype. Initialized separately for each instance of House.
    // Each relation must define (as a minimum) the 'type', 'key' and 'relatedModel'. Options are
    // 'includeInJSON', 'createModels' and 'reverseRelation', which takes the same options as the relation itself.
    relations: [
        {
            type: Backbone.HasMany, // Use the type, or the string 'HasOne' or 'HasMany'.
            key: 'occupants',
            relatedModel: 'Person',
            includeInJSON: Backbone.Model.prototype.idAttribute,
            collectionType: 'PersonCollection',
            reverseRelation: {
                key: 'livesIn'
            }
        }
    ]
});

Person = Backbone.RelationalModel.extend({
    relations: [
        { // Create a (recursive) one-to-one relationship
            type: Backbone.HasOne,
            key: 'user',
            relatedModel: 'User',
            reverseRelation: {
                type: Backbone.HasOne,
                key: 'person'
            }
        }
    ],

    initialize: function() {
        // do whatever you want :)
    }
});

PersonCollection = Backbone.Collection.extend({
    url: function( models ) {
        // Logic to create a url for the whole collection, or a set of models.
        // See the tests, or Backbone-tastypie, for an example.
        return '/person/' + ( models ? 'set/' + _.pluck( models, 'id' ).join(';') + '/' : '' );
    }
});

User = Backbone.RelationalModel.extend();</code>
</pre>

  <h2 id="under-the-hood">Under the Hood</h2>

  <p>Each <b>Backbone.RelationalModel</b> registers itself with <b>Backbone.Store</b> upon
     creation (and is removed from the Store when destroyed). When creating or updating an
     attribute that is a key in a relation, removed related objects are notified of their
     removal, and new related objects are looked up in the Store.</p>

  </div>

  <script src="docs/static/js/prism.js"></script>
</body>
</html>
